"""
Core Data Models for Cthulhu Solo TRPG System

This module defines the fundamental data structures used throughout the game
as specified in the Program Development Document (PDD).
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Any, Optional
import time


class TensionLevel(Enum):
    """Represents the current tension/horror level in the game"""
    CALM = "calm"
    UNEASY = "uneasy"
    TENSE = "tense"
    TERRIFYING = "terrifying"
    COSMIC_HORROR = "cosmic_horror"


class ActionType(Enum):
    """Types of player actions that can be performed"""
    INVESTIGATE = "investigate"
    INTERACT = "interact"
    MOVEMENT = "movement"
    COMBAT = "combat"
    DIALOGUE = "dialogue"
    OTHER = "other"


@dataclass
class StoryContent:
    """
    Represents a piece of narrative content generated by the story system.
    
    This is the primary data structure for all story-related content,
    including scene descriptions, action results, and narrative progression.
    """
    text: str  # The main narrative text
    content_id: str  # Unique identifier for this content
    scene_id: str  # Identifier for the current scene/location
    tension_level: TensionLevel  # Current horror/tension level
    metadata: Dict[str, Any] = field(default_factory=dict)  # Additional metadata
    investigation_opportunities: List[str] = field(default_factory=list)  # Available investigations
    story_threads: Dict[str, Any] = field(default_factory=dict)  # Active story threads with status
    timestamp: float = field(default_factory=time.time)  # When this content was created
    
    def __post_init__(self):
        """Validate the story content after initialization"""
        if not self.text.strip():
            raise ValueError("Story content text cannot be empty")
        if not self.content_id:
            raise ValueError("Content ID cannot be empty")
        if not self.scene_id:
            raise ValueError("Scene ID cannot be empty")


@dataclass
class NarrativeContext:
    """
    Comprehensive context information for narrative generation.
    
    This context is used by AI agents to generate appropriate responses
    and maintain narrative consistency.
    """
    scene_id: str  # Current scene/location identifier
    turn_number: int  # Current turn in the game
    story_threads: Dict[str, Any] = field(default_factory=dict)  # Active story threads with state
    choice_history: List[str] = field(default_factory=list)  # History of player choices
    narrative_flags: Dict[str, Any] = field(default_factory=dict)  # Story flags and variables
    character_state: Dict[str, Any] = field(default_factory=dict)  # Character stats and condition
    tension_level: TensionLevel = TensionLevel.CALM  # Current tension level
    location_state: Dict[str, Any] = field(default_factory=dict)  # Location-specific state
    npc_relationships: Dict[str, Any] = field(default_factory=dict)  # NPC relationship tracking
    investigation_history: List[str] = field(default_factory=list)  # Previous investigations
    
    def get_context_summary(self) -> Dict[str, Any]:
        """Return a summary of the current context for AI agents"""
        return {
            "scene_id": self.scene_id,
            "turn_number": self.turn_number,
            "tension_level": self.tension_level.value,
            "active_threads": len(self.story_threads),
            "recent_choices": self.choice_history[-5:] if self.choice_history else [],
            "investigation_count": len(self.investigation_history),
            "location_explored": len(self.location_state),
        }


@dataclass
class AgentMemory:
    """
    Memory structure for AI agents to maintain context and continuity.
    
    Each memory has content, importance scoring, and metadata for
    efficient retrieval and relevance calculation.
    """
    content: str  # The memory content
    timestamp: float  # When this memory was created
    importance: int  # Importance score (1-10)
    metadata: Dict[str, Any] = field(default_factory=dict)  # Additional metadata
    memory_type: str = "general"  # Type of memory (general, dialogue, investigation, etc.)
    scene_context: str = ""  # Scene where this memory was created
    relevance_keywords: List[str] = field(default_factory=list)  # Keywords for relevance matching
    
    def __post_init__(self):
        """Validate memory data after initialization"""
        if not self.content.strip():
            raise ValueError("Memory content cannot be empty")
        if not 1 <= self.importance <= 10:
            raise ValueError("Memory importance must be between 1 and 10")
        if self.timestamp <= 0:
            self.timestamp = time.time()


@dataclass
class GameState:
    """
    Complete game state that can be saved/loaded.
    
    This represents the entire state of a game session including
    character data, narrative context, and system state.
    """
    character_data: Dict[str, Any]  # Character stats, skills, inventory
    narrative_context: NarrativeContext  # Current narrative state
    game_metadata: Dict[str, Any] = field(default_factory=dict)  # Game session metadata
    save_timestamp: float = field(default_factory=time.time)  # When this state was saved
    version: str = "1.0.0"  # Game version
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert game state to dictionary for serialization"""
        return {
            "character_data": self.character_data,
            "narrative_context": {
                "scene_id": self.narrative_context.scene_id,
                "turn_number": self.narrative_context.turn_number,
                "story_threads": self.narrative_context.story_threads,
                "choice_history": self.narrative_context.choice_history,
                "narrative_flags": self.narrative_context.narrative_flags,
                "character_state": self.narrative_context.character_state,
                "tension_level": self.narrative_context.tension_level.value,
                "location_state": self.narrative_context.location_state,
                "npc_relationships": self.narrative_context.npc_relationships,
                "investigation_history": self.narrative_context.investigation_history,
            },
            "game_metadata": self.game_metadata,
            "save_timestamp": self.save_timestamp,
            "version": self.version,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GameState':
        """Create game state from dictionary (for loading)"""
        # Reconstruct narrative context
        nc_data = data["narrative_context"]
        narrative_context = NarrativeContext(
            scene_id=nc_data["scene_id"],
            turn_number=nc_data["turn_number"],
            story_threads=nc_data.get("story_threads", {}),
            choice_history=nc_data.get("choice_history", []),
            narrative_flags=nc_data.get("narrative_flags", {}),
            character_state=nc_data.get("character_state", {}),
            tension_level=TensionLevel(nc_data.get("tension_level", "calm")),
            location_state=nc_data.get("location_state", {}),
            npc_relationships=nc_data.get("npc_relationships", {}),
            investigation_history=nc_data.get("investigation_history", []),
        )
        
        return cls(
            character_data=data["character_data"],
            narrative_context=narrative_context,
            game_metadata=data.get("game_metadata", {}),
            save_timestamp=data.get("save_timestamp", time.time()),
            version=data.get("version", "1.0.0"),
        )


@dataclass
class PlayerAction:
    """
    Represents a processed player action with analysis results.
    
    This structure contains the original player input and the
    AI analysis of what the player intends to do.
    """
    original_text: str  # Original player input
    action_type: ActionType  # Classified action type
    target: str = ""  # Target of the action (object, NPC, location, etc.)
    intent: str = ""  # Parsed intent description
    parameters: Dict[str, Any] = field(default_factory=dict)  # Additional action parameters
    confidence: float = 1.0  # Confidence in the action parsing (0.0-1.0)
    timestamp: float = field(default_factory=time.time)  # When this action was processed
    
    def __post_init__(self):
        """Validate action data"""
        if not self.original_text.strip():
            raise ValueError("Player action text cannot be empty")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")


@dataclass
class Investigation:
    """
    Represents an investigation opportunity in the game.
    
    Investigations are contextual opportunities for players to
    gather information or discover clues.
    """
    description: str  # Description of what can be investigated
    difficulty: int = 5  # Difficulty level (1-10)
    scene_id: str = ""  # Scene where this investigation is available
    keywords: List[str] = field(default_factory=list)  # Keywords that trigger this investigation
    rewards: List[str] = field(default_factory=list)  # Potential rewards/clues
    requirements: Dict[str, Any] = field(default_factory=dict)  # Requirements to attempt
    one_time: bool = False  # Whether this can only be done once
    
    def can_attempt(self, character_state: Dict[str, Any], narrative_flags: Dict[str, Any]) -> bool:
        """Check if the character can attempt this investigation"""
        # Check basic requirements
        for requirement, value in self.requirements.items():
            if requirement in character_state:
                if character_state[requirement] < value:
                    return False
            elif requirement in narrative_flags:
                if not narrative_flags[requirement]:
                    return False
        return True


# Utility functions for working with the data models

def create_basic_narrative_context(scene_id: str, character_data: Dict[str, Any]) -> NarrativeContext:
    """Create a basic narrative context for a new scene"""
    return NarrativeContext(
        scene_id=scene_id,
        turn_number=1,
        character_state=character_data.copy(),
        tension_level=TensionLevel.CALM,
    )


def calculate_memory_relevance(memory: AgentMemory, context_keywords: List[str], 
                             current_scene: str, current_time: float) -> float:
    """
    Calculate relevance score for a memory based on context.
    
    This implements the algorithm specified in PDD section 5.1.
    """
    # Keyword matching score
    keyword_score = sum(1 for kw in context_keywords 
                       if kw.lower() in memory.content.lower() or 
                       kw.lower() in memory.relevance_keywords)
    
    # Recency score (higher for more recent memories)
    time_diff = current_time - memory.timestamp
    recency_score = 1.0 / (1.0 + time_diff / 3600)  # Decay over hours
    
    # Importance score (normalized)
    importance_score = memory.importance / 10.0
    
    # Scene relevance bonus
    scene_bonus = 0.2 if memory.scene_context == current_scene else 0.0
    
    # Weighted total
    total_score = (keyword_score * 0.4 + 
                   recency_score * 0.3 + 
                   importance_score * 0.3 + 
                   scene_bonus)
    
    return total_score


def tension_level_from_string(value: str) -> TensionLevel:
    """Convert string to TensionLevel enum, with fallback"""
    try:
        return TensionLevel(value.lower())
    except ValueError:
        return TensionLevel.CALM


def action_type_from_string(value: str) -> ActionType:
    """Convert string to ActionType enum, with fallback"""
    try:
        return ActionType(value.lower())
    except ValueError:
        return ActionType.OTHER